---
title: "DEFT CODING :D "
author: "Daniel Zweben"
date: "2024-11-03"
output: html_document
---
#### READ IN DATA FRAME FROM REDCAP

```{r}
# Install if needed
#install.packages("readxl")

# Load the package
library(readxl)

# Read the Excel file
df <- read_excel("/Users/dannyzweben/Desktop/CABLAB_Files/deft/coding/C_data.xlsx")

# View the first few rows
head(df)
```


```{r}
library(dplyr)
library(stringr)

# Step 1: Clean the strings — trim whitespace and normalize dashes
df <- df %>%
  mutate(across(
    c(fb_time, twitter_time, yt_time, inst_time, snap_time),
    ~ str_replace_all(str_trim(.), "–", "-")  # replaces en-dash with hyphen
  ))

# Step 2: Recode to numeric
df <- df %>%
  mutate(across(
    c(fb_time, twitter_time, yt_time, inst_time, snap_time),
    ~ as.numeric(recode(.,
      "Not installed" = 0,
      "Rarely ever use" = 1,
      "5-10 minutes" = 2,
      "10-20 minutes" = 3,
      "20-40 minutes" = 4,
      "40-60 minutes" = 5,
      "Over an hour per day" = 6
    ))
  ))


```

```{r}
df <- df %>%
  mutate(
    social_score = fb_time + snap_time + inst_time,
    parasocial_score = twitter_time + yt_time
  )

```

```{r}
df1 <- select(df, social_score, parasocial_score)
```

```{r}
write.csv(df1, "/Users/dannyzweben/Desktop/CABLAB_Files/deft/coding/social.csv", row.names = FALSE)

```



######### ANALYSES USING DEFT DATA SET ############


```{r}

# Install if needed

# Load the package
library(readxl)

# Read the Excel file
df_run <- read_excel("/Users/dannyzweben/Desktop/CABLAB_Files/deft/coding/DEFT_export_reduced.xlsx")

# View the first few rows
head(df)


df_run <- df_run %>%
  mutate(across(
    c(pnrt_pos, pnrt_neg, brp_hsn, social_score, parasocial_score, 'Risk Variety'),
    ~ scale(.)[, 1]
  ))


```

outlier removal
```{r}
df_run[] <- lapply(df_run, function(x) replace(x, abs(x) > 3, NA))

```




Hierachical Regression - Parasocial

```{r}


# Step 1: Control + Impulsivity
model1 <- lm(parasocial_score ~ Gender + impulsivity, data = df_run)

# Step 2: Add ss
model2 <- lm(parasocial_score ~ Gender + impulsivity + ss, data = df_run)

# Step 3: Add exploration
model3 <- lm(parasocial_score ~ Gender + impulsivity + ss + exploration, data = df_run)

# Step 4: Add pnrt_pos, pnrt_neg, brp_hsn
model4 <- lm(parasocial_score ~ Gender + impulsivity + ss + exploration + pnrt_pos + pnrt_neg + brp_hsn, data = df_run)

summary(model1)
summary(model2)
summary(model3)
summary(model4)
anova(model1, model2, model3, model4)



```

Hierachical Regression -- social_score

```{r}


# Step 1: Control + Impulsivity
model1 <- lm(social_score ~ Gender + impulsivity, data = df_run)

# Step 2: Add ss
model2 <- lm(social_score ~ Gender + impulsivity + ss, data = df_run)

# Step 3: Add exploration
model3 <- lm(social_score ~ Gender + impulsivity + ss + exploration, data = df_run)

# Step 4: Add pnrt_pos, pnrt_neg, brp_hsn
model4 <- lm(social_score ~ Gender + impulsivity + ss + exploration + pnrt_pos + pnrt_neg + brp_hsn, data = df_run)


summary(model1)
summary(model2)
summary(model3)
summary(model4)
anova(model1, model2, model3, model4)



```

```{r}
library(psych)
library(dplyr)

# Select new variables
cor_df <- df_run %>%
  select(brp_hsn, pnrt_neg, pnrt_pos, parasocial_score, social_score)

# Run correlation test
corr <- corr.test(cor_df, use = "pairwise", method = "pearson")

# Round r and p values
r_vals <- round(corr$r, 2)
p_vals <- round(corr$p, 3)

# Create labeled matrix: "r = ..., p = ..."
formatted <- matrix(NA, nrow = nrow(r_vals), ncol = ncol(r_vals),
                    dimnames = dimnames(r_vals))

for (i in 1:nrow(formatted)) {
  for (j in 1:i) {
    formatted[i, j] <- paste0("r = ", r_vals[i, j], ", p = ", p_vals[i, j])
  }
}

# Convert to data frame
formatted_df <- as.data.frame(formatted)
formatted_df


```

FISCHERS/STEIGERS
```{r}
library(cocor)
library(dplyr)

# Function to run Steiger's test and extract z + p
run_steiger_df <- function(predictor, df) {
  r12 <- cor(df[[predictor]], df$parasocial_score, use = "pairwise.complete.obs")
  r13 <- cor(df[[predictor]], df$social_score, use = "pairwise.complete.obs")
  r23 <- cor(df$parasocial_score, df$social_score, use = "pairwise.complete.obs")
  n <- nrow(na.omit(df[, c(predictor, "parasocial_score", "social_score")]))
  
  result <- cocor.dep.groups.overlap(r.jk = r12, r.jh = r13, r.kh = r23, n = n)
  steiger <- result@steiger1980
  
  # Return as a data frame row
  data.frame(
    predictor = predictor,
    r_parasocial = round(r12, 3),
    r_social = round(r13, 3),
    r_diff = round(r12 - r13, 3),
    z = round(steiger$statistic, 3),
    p = round(steiger$p.value, 3)
  )
}

# Run for all predictors and bind rows
predictors <- c("brp_hsn", "pnrt_neg", "pnrt_pos")
steiger_results_df <- do.call(rbind, lapply(predictors, run_steiger_df, df = df_run))

# Adjust for multiple comparisons: Unnecesary here. 
#steiger_results_df$p_bonf <- p.adjust(steiger_results_df$p, method = "bonferroni")
#steiger_results_df$p_holm <- p.adjust(steiger_results_df$p, method = "holm")
#steiger_results_df$p_fdr <- p.adjust(steiger_results_df$p, method = "fdr")


# Show results
steiger_results_df


```




re run overall correlation -- (ALL CORRELATIONS) - just checkin :D
```{r}
library(Hmisc)
num_df <- df_run[sapply(df_run, is.numeric)]
res <- Hmisc::rcorr(as.matrix(num_df))
rp_mat <- matrix("", ncol = ncol(num_df), nrow = ncol(num_df))
rp_mat[lower.tri(rp_mat)] <- paste0(round(res$r[lower.tri(res$r)], 2), ", p=", round(res$P[lower.tri(res$P)], 3))
colnames(rp_mat) <- rownames(rp_mat) <- colnames(num_df)
as.data.frame(rp_mat)

```

##### 


re OG correlations with total risk -
```{r}
library(Hmisc)

# pick only the 4 variables you care about
vars <- c("MTES", "impulsivity", "ss", "exploration", "Risk Variety")
num_df <- df_run[vars]

# run rcorr
res <- Hmisc::rcorr(as.matrix(num_df))

# format r,p matrix
rp_mat <- matrix("", ncol = ncol(num_df), nrow = ncol(num_df))
rp_mat[lower.tri(rp_mat)] <- paste0(
  round(res$r[lower.tri(res$r)], 2), 
  ", p=", round(res$P[lower.tri(res$P)], 3)
)

colnames(rp_mat) <- rownames(rp_mat) <- colnames(num_df)

as.data.frame(rp_mat)

```

re OG correlations with risk split up risk -
```{r}
library(Hmisc)

# pick only the 4 variables you care about
vars <- c("MTES", "impulsivity", "ss", "exploration", "brp_hsn", "pnrt_neg", "pnrt_pos" )
num_df <- df_run[vars]

# run rcorr
res <- Hmisc::rcorr(as.matrix(num_df))

# format r,p matrix
rp_mat <- matrix("", ncol = ncol(num_df), nrow = ncol(num_df))
rp_mat[lower.tri(rp_mat)] <- paste0(
  round(res$r[lower.tri(res$r)], 2), 
  ", p=", round(res$P[lower.tri(res$P)], 3)
)

colnames(rp_mat) <- rownames(rp_mat) <- colnames(num_df)

as.data.frame(rp_mat)

```



Re-Running the mediations: 
```{r}
# Load required libraries
library(dplyr)
library(mediation)  # Make sure this is installed

# Clean and filter your data
mediation_df <- df_run %>%
  mutate(
    MTES = as.numeric(MTES),
    ss = as.numeric(ss),
    impulsivity = as.numeric(impulsivity),
    exploration = as.numeric(exploration),
    `Risk Variety` = as.numeric(`Risk Variety`)
  ) %>%
  filter(
    !is.na(MTES),
    !is.na(ss),
    !is.na(impulsivity),
    !is.na(exploration),
    !is.na(`Risk Variety`)
  )

# -------- Reward Sensitivity (ss) → Risk Variety → MTES --------
med_model_ss <- lm(`Risk Variety` ~ ss, data = mediation_df)
out_model_ss <- lm(MTES ~ ss + `Risk Variety`, data = mediation_df)

mediation_ss <- mediation::mediate(
  med_model_ss,
  out_model_ss,
  treat = "ss",
  mediator = "Risk Variety",
  boot = TRUE,
  sims = 1000
)

# -------- Exploration → Risk Variety → MTES --------
med_model_expl <- lm(`Risk Variety` ~ exploration, data = mediation_df)
out_model_expl <- lm(MTES ~ exploration + `Risk Variety`, data = mediation_df)

mediation_expl <- mediation::mediate(
  med_model_expl,
  out_model_expl,
  treat = "exploration",
  mediator = "Risk Variety",
  boot = TRUE,
  sims = 1000
)

# -------- Impulsivity → Risk Variety → MTES --------
med_model_imp <- lm(`Risk Variety` ~ impulsivity, data = mediation_df)
out_model_imp <- lm(MTES ~ impulsivity + `Risk Variety`, data = mediation_df)

mediation_imp <- mediation::mediate(
  med_model_imp,
  out_model_imp,
  treat = "impulsivity",
  mediator = "Risk Variety",
  boot = TRUE,
  sims = 1000
)

# -------- Print results --------
cat("\n=== Mediation: Reward Sensitivity → Risk Variety → MTES ===\n")
summary(mediation_ss)

cat("\n=== Mediation: Exploration → Risk Variety → MTES ===\n")
summary(mediation_expl)

cat("\n=== Mediation: Impulsivity → Risk Variety → MTES ===\n")
summary(mediation_imp)


```

another method to double check
```{r}

## reward: 

# Load required packages
library(dplyr)
library(boot)

# Clean and rename relevant variables locally
med_data <- df_run %>%
  dplyr::select(`Risk Variety`, ss, MTES) %>%
  rename(
    risk = `Risk Variety`,
    reward = ss,
    tech = MTES
  ) %>%
  na.omit()

# Step 1: a path (reward → risk)
model_a <- lm(risk ~ reward, data = med_data)
a_coef <- coef(model_a)["reward"]

# Step 2: b path (risk → tech, controlling for reward)
model_b <- lm(tech ~ risk + reward, data = med_data)
b_coef <- coef(model_b)["risk"]

# Step 3: Indirect effect = a * b
indirect_effect <- a_coef * b_coef
cat("Indirect effect (a*b):", round(indirect_effect, 3), "\n")

# Step 4: Total effect (reward → tech)
model_c <- lm(tech ~ reward, data = med_data)
total_effect <- coef(model_c)["reward"]
cat("Total effect (c):", round(total_effect, 3), "\n")

# Step 5: Direct effect (reward → tech, controlling for risk)
direct_effect <- coef(model_b)["reward"]
cat("Direct effect (c'):", round(direct_effect, 3), "\n")

# ---- BOOTSTRAPPING INDIRECT EFFECT ----
boot_indirect <- function(data, indices) {
  d <- data[indices, ]
  tryCatch({
    a <- coef(lm(risk ~ reward, data = d))["reward"]
    b <- coef(lm(tech ~ risk + reward, data = d))["risk"]
    return(a * b)
  }, error = function(e) return(NA))
}

set.seed(123)
boot_results <- boot(data = med_data, statistic = boot_indirect, R = 1000)

# Show bootstrapped 95% confidence interval for indirect effect
boot_ci <- boot.ci(boot_results, type = "perc")

# Print results
cat("\n==== Bootstrapped Mediation Results ====\n")
cat("Indirect effect (a*b):", round(indirect_effect, 3), "\n")
cat("Direct effect (c'):", round(direct_effect, 3), "\n")
cat("Total effect (c):", round(total_effect, 3), "\n")
print(boot_ci)
print(boot_results)


```



Re-running the Shapley: 

```{r}
# Load required packages
library(dplyr)
library(tidyr)
library(ShapleyValue)
library(kableExtra)

# Function to run Shapley and return formatted output
run_shapley <- function(data, dv_name) {
  # Rename problematic variable and select needed columns
  shap_df <- data %>%
    dplyr::rename(risk_variety = `Risk Variety`) %>%
    dplyr::select(all_of(c(dv_name, "risk_variety", "ss", "impulsivity", "exploration", "Gender"))) %>%
    tidyr::drop_na()

  # Print sample size used
  cat("N used (complete cases):", nrow(shap_df), "\n")

  # Define DV and predictors
  y <- shap_df[[dv_name]]
  x <- shap_df %>% dplyr::select(-all_of(dv_name)) %>% as.data.frame()

  # Run Shapley value analysis
  shap_values <- shapleyvalue(y = y, x = x)

  # Format and print output
  shap_df_out <- as.data.frame(shap_values)
  percent_row <- round(as.numeric(shap_df_out[2, ]) * 100, 2)
  shap_df_out[2, ] <- paste0(percent_row, "%")
  rownames(shap_df_out) <- c("Shapley Value", "Percent of R²")

  return(shap_df_out)
}

# Run Shapley analysis on your df_run predicting MTES
shapley_results_mtes <- run_shapley(df_run, "MTES")

# Print clean table
print(
  kbl(shapley_results_mtes, align = "c", caption = "Shapley Value Regression for MTES") %>%
    kable_classic(full_width = FALSE, html_font = "Cambria")
)

```


Re-running the OG hierachichal regression: 

```{r}
# Load required package
library(lm.beta)
library(dplyr)

# Drop missing data for all relevant variables BEFORE fitting models
clean_df <- df_run %>%
  dplyr::select(MTES, Gender, impulsivity, ss, exploration, pnrt_pos, pnrt_neg, brp_hsn) %>%
  na.omit()

# Fit models on clean_df
model1 <- lm(MTES ~ Gender + impulsivity, data = clean_df)
model2 <- lm(MTES ~ Gender + impulsivity + ss, data = clean_df)
model3 <- lm(MTES ~ Gender + impulsivity + ss + exploration, data = clean_df)
model4 <- lm(MTES ~ Gender + impulsivity + ss + exploration + pnrt_pos + pnrt_neg + brp_hsn, data = clean_df)

# Get standardized versions
model1_std <- lm.beta(model1)
model2_std <- lm.beta(model2)
model3_std <- lm.beta(model3)
model4_std <- lm.beta(model4)

# Output summaries
cat("\n=== Model 1 ===\n")
summary(model1)
summary(model1_std)

cat("\n=== Model 2 ===\n")
summary(model2)
summary(model2_std)

cat("\n=== Model 3 ===\n")
summary(model3)
summary(model3_std)

cat("\n=== Model 4 ===\n")
summary(model4)
summary(model4_std)

# Now this will work!
anova(model1, model2, model3, model4)
    

```

